// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Binding to the C++ engine
class FFIEngine {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FFIEngine(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FFIEngine.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  late final ffi.Pointer<Square> _kPassMove = _lookup<Square>('kPassMove');

  int get kPassMove => _kPassMove.value;

  late final ffi.Pointer<Square> _kStartingPositionMove =
      _lookup<Square>('kStartingPositionMove');

  int get kStartingPositionMove => _kStartingPositionMove.value;

  int PassMove() {
    return _PassMove();
  }

  late final _PassMovePtr =
      _lookup<ffi.NativeFunction<Square Function()>>('PassMove');
  late final _PassMove = _PassMovePtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Void> MainInit(
    ffi.Pointer<ffi.Char> evals_filepath,
    ffi.Pointer<ffi.Char> book_filepath,
    ffi.Pointer<ffi.Char> thor_filepath,
    SetBoard set_board,
    UpdateAnnotations update_annotations,
  ) {
    return _MainInit(
      evals_filepath,
      book_filepath,
      thor_filepath,
      set_board,
      update_annotations,
    );
  }

  late final _MainInitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              SetBoard,
              UpdateAnnotations)>>('MainInit');
  late final _MainInit = _MainInitPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          SetBoard,
          UpdateAnnotations)>();

  ffi.Pointer<ThorMetadata> MainGetThorMetadata(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _MainGetThorMetadata(
      ptr,
    );
  }

  late final _MainGetThorMetadataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ThorMetadata> Function(
              ffi.Pointer<ffi.Void>)>>('MainGetThorMetadata');
  late final _MainGetThorMetadata = _MainGetThorMetadataPtr.asFunction<
      ffi.Pointer<ThorMetadata> Function(ffi.Pointer<ffi.Void>)>();

  void MainDelete(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _MainDelete(
      ptr,
    );
  }

  late final _MainDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'MainDelete');
  late final _MainDelete =
      _MainDeletePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<EvaluateParams> MainGetEvaluateParams(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _MainGetEvaluateParams(
      ptr,
    );
  }

  late final _MainGetEvaluateParamsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<EvaluateParams> Function(
              ffi.Pointer<ffi.Void>)>>('MainGetEvaluateParams');
  late final _MainGetEvaluateParams = _MainGetEvaluateParamsPtr.asFunction<
      ffi.Pointer<EvaluateParams> Function(ffi.Pointer<ffi.Void>)>();

  void NewGame(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _NewGame(
      ptr,
    );
  }

  late final _NewGamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'NewGame');
  late final _NewGame =
      _NewGamePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void PlayMove(
    ffi.Pointer<ffi.Void> ptr,
    int square,
  ) {
    return _PlayMove(
      ptr,
      square,
    );
  }

  late final _PlayMovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int)>>('PlayMove');
  late final _PlayMove =
      _PlayMovePtr.asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  bool SetSequence(
    ffi.Pointer<ffi.Void> ptr,
    ffi.Pointer<ffi.Char> sequence,
  ) {
    return _SetSequence(
      ptr,
      sequence,
    );
  }

  late final _SetSequencePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>>('SetSequence');
  late final _SetSequence = _SetSequencePtr.asFunction<
      bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> GetSequence(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _GetSequence(
      ptr,
    );
  }

  late final _GetSequencePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Void>)>>('GetSequence');
  late final _GetSequence = _GetSequencePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Void>)>();

  void Undo(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _Undo(
      ptr,
    );
  }

  late final _UndoPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'Undo');
  late final _Undo =
      _UndoPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void SetCurrentMove(
    ffi.Pointer<ffi.Void> ptr,
    int current_move,
  ) {
    return _SetCurrentMove(
      ptr,
      current_move,
    );
  }

  late final _SetCurrentMovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int)>>('SetCurrentMove');
  late final _SetCurrentMove = _SetCurrentMovePtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, int)>();

  void Redo(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _Redo(
      ptr,
    );
  }

  late final _RedoPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'Redo');
  late final _Redo =
      _RedoPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void ToAnalyzedGameOrFirstState(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _ToAnalyzedGameOrFirstState(
      ptr,
    );
  }

  late final _ToAnalyzedGameOrFirstStatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'ToAnalyzedGameOrFirstState');
  late final _ToAnalyzedGameOrFirstState = _ToAnalyzedGameOrFirstStatePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void Evaluate(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _Evaluate(
      ptr,
    );
  }

  late final _EvaluatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'Evaluate');
  late final _Evaluate =
      _EvaluatePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  void Analyze(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _Analyze(
      ptr,
    );
  }

  late final _AnalyzePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'Analyze');
  late final _Analyze =
      _AnalyzePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<Annotations> GetCurrentAnnotations(
    ffi.Pointer<ffi.Void> ptr,
    int current_thread,
  ) {
    return _GetCurrentAnnotations(
      ptr,
      current_thread,
    );
  }

  late final _GetCurrentAnnotationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Annotations> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('GetCurrentAnnotations');
  late final _GetCurrentAnnotations = _GetCurrentAnnotationsPtr.asFunction<
      ffi.Pointer<Annotations> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<Annotations> GetStartAnnotations(
    ffi.Pointer<ffi.Void> ptr,
    int current_thread,
  ) {
    return _GetStartAnnotations(
      ptr,
      current_thread,
    );
  }

  late final _GetStartAnnotationsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Annotations> Function(
              ffi.Pointer<ffi.Void>, ffi.Int)>>('GetStartAnnotations');
  late final _GetStartAnnotations = _GetStartAnnotationsPtr.asFunction<
      ffi.Pointer<Annotations> Function(ffi.Pointer<ffi.Void>, int)>();

  void Stop(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _Stop(
      ptr,
    );
  }

  late final _StopPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'Stop');
  late final _Stop =
      _StopPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();
}

typedef Square = ffi.Uint8;
typedef DartSquare = int;

final class ThorSourceMetadata extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<ffi.Pointer<ffi.Char>> players;

  @ffi.Int()
  external int num_players;

  external ffi.Pointer<ffi.Pointer<ffi.Char>> tournaments;

  @ffi.Int()
  external int num_tournaments;

  external ffi.Pointer<ffi.Int> selected_blacks;

  external ffi.Pointer<ffi.Int> selected_whites;

  external ffi.Pointer<ffi.Int> selected_tournaments;

  @ffi.Bool()
  external bool active;
}

final class ThorMetadata extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<ThorSourceMetadata>> sources;

  @ffi.Int()
  external int num_sources;
}

final class BoardUpdate extends ffi.Struct {
  @BitPattern()
  external int player;

  @BitPattern()
  external int opponent;

  @ffi.Bool()
  external bool black_turn;
}

typedef BitPattern = ffi.Uint64;
typedef DartBitPattern = int;

final class ThorGame extends ffi.Struct {
  external ffi.Pointer<ffi.Char> black;

  external ffi.Pointer<ffi.Char> white;

  external ffi.Pointer<ffi.Char> tournament;

  @ffi.Array.multi([60])
  external ffi.Array<Square> moves;

  @ffi.Int()
  external int moves_played;

  @ffi.Int()
  external int score;

  @ffi.Int()
  external int year;
}

abstract class AnnotationsProvenance {
  static const int EVALUATE = 0;
  static const int BOOK = 1;
  static const int EVALUATE_MIXED = 2;
  static const int CHILD_EVALUATE = 3;
  static const int CHILD_BOOK = 4;
  static const int CHILD_MIXED = 5;
  static const int GAME_OVER = 6;
}

final class Annotations extends ffi.Struct {
  @Square()
  external int move;

  @ffi.Bool()
  external bool black_turn;

  @ffi.Int()
  external int depth;

  external ffi.Pointer<Annotations> father;

  external ffi.Pointer<Annotations> first_child;

  external ffi.Pointer<Annotations> next_sibling;

  external ffi.Pointer<Annotations> next_state_played;

  external ffi.Pointer<Annotations> next_state_in_analysis;

  @ffi.Bool()
  external bool valid;

  @ffi.Double()
  external double eval;

  @ffi.Double()
  external double leaf_eval;

  @ffi.Double()
  external double eval_best_line;

  @ffi.Int()
  external int median_eval;

  @ffi.Int()
  external int median_eval_best_line;

  @ffi.Int32()
  external int provenance;

  @ffi.Bool()
  external bool derived;

  @ffi.Double()
  external double prob_lower_eval;

  @ffi.Double()
  external double prob_upper_eval;

  @ffi.Double()
  external double proof_number_lower;

  @ffi.Double()
  external double disproof_number_upper;

  @Eval()
  external int lower;

  @Eval()
  external int upper;

  @Eval()
  external int weak_lower;

  @Eval()
  external int weak_upper;

  @ffi.Double()
  external double seconds;

  @NVisited()
  external int descendants;

  @NVisited()
  external int descendants_book;

  @ffi.Double()
  external double missing;

  @ffi.UnsignedInt()
  external int num_thor_games;

  external ffi.Pointer<ThorGame> example_thor_games;

  @ffi.UnsignedInt()
  external int num_example_thor_games;

  @ffi.Double()
  external double thor_winning_percentage;

  @ffi.Bool()
  external bool during_analysis;
}

typedef Eval = ffi.Int8;
typedef DartEval = int;
typedef NVisited = ffi.Uint64;
typedef DartNVisited = int;

final class ThorParams extends ffi.Struct {
  @ffi.Int()
  external int max_games;

  @ffi.Int()
  external int start_year;

  @ffi.Int()
  external int end_year;
}

final class EvaluateParams extends ffi.Struct {
  @ffi.Int()
  external int lower;

  @ffi.Int()
  external int upper;

  @NVisited()
  external int max_positions;

  @ffi.Double()
  external double max_time_first_eval;

  @ffi.Double()
  external double max_time_next_evals;

  @ffi.Double()
  external double max_time_analysis;

  @ffi.Int()
  external int n_threads;

  @ffi.Double()
  external double delta;

  @ffi.Bool()
  external bool approx;

  @ffi.Bool()
  external bool use_book;

  external ThorParams thor_filters;
}

typedef SetBoard = ffi.Pointer<ffi.NativeFunction<SetBoardFunction>>;
typedef SetBoardFunction = ffi.Void Function(BoardUpdate);
typedef DartSetBoardFunction = void Function(BoardUpdate);
typedef UpdateAnnotations
    = ffi.Pointer<ffi.NativeFunction<UpdateAnnotationsFunction>>;
typedef UpdateAnnotationsFunction = ffi.Void Function(ffi.Int, ffi.Bool);
typedef DartUpdateAnnotationsFunction = void Function(int, bool);
